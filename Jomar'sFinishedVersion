; Interrupt Management Demostration
; Program Port 1 to generate an interrupt everytime the push button
; S1 on the launchpad is pressed. The first time the red LED will 
; be light on. The second time the green LED will be light on. Next
; times will cause no changes.


#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     01C00h                  ; To count how many times button S1 
pushCount dw    0                       ; is pressed
seconds         DW 0
timerResets     DW 0                    ;When this hits 5, a second has passed

;Digits      0     1     2     3     4     5     6     7     8     9      B     P     M   
DigitH   db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0xF1, 0xCF, 0x6C
DigitL   db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0xA0

;Letters    O      P     T     I     N     R    E      A     D     L    G     B     P     M     S     V
letterH db 0xFC, 0xCF, 0x80, 0x90, 0x6C, 0xCF, 0x9F, 0xEF, 0xF0, 0x1C, 0xBD, 0xF1, 0xCF, 0x6C, 0xB7, 0x0C
letterL db 0x00, 0x00, 0x50, 0x50, 0x82, 0x02, 0x00, 0x00, 0x50, 0x00, 0x00, 0x50, 0x00, 0xA0, 0x00, 0x28

;Bat Seg     0     1     2     3     4     5    6
BatH     db 0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0
BatL     db 0x00, 0x00, 0x20, 0x20, 0x60, 0x60, 0xE0


        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDEh                  ; vector for TIMER_A1
        DC16    TIMER_A1_ISR            ; set vector for 'TIMER_A1_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

;Has some design errors like not initializing pushCount to 0 in the code.
;The program don't clear the push button interrupt flag at the beginning
;leaving the possibility of a false interrupt due to a previous push
;(this is solved uncommenting the two lines of codes)

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

        bis.b   #06h, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1
        bis.b   #06h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

//        mov     #0, pushCount         ; When using reset with the debugger
                                        ; the memory content is not reset to
                                        ; original values. To take care of
                                        ; that situation pushCount is reset
                                        ; to 0

        bic.b   #00000110b, &P1IFG    ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        MOV.W   #0x041e,&LCDCCTL0

        MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL     ;Clock sync Enabled


        MOV.W   #2,&LCDCMEMCTL         ;Clear LCD
        BIS.W   #1,&LCDCCTL0


        Mov     #0,R13


Start:
        Call    #Option


        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)


normal_fin:
        ret


;Objective: A delay to accurately carry out the functions of the calculator
;Preconditions: This function passes a 50000 to R13
;Postconditions: 
;Author: Jomar Santos
;Date:         
Delay:                                   
        MOV     #65000,R10   

;Objective: Loop through Next until R13 is 0.
;Preconditions: 
;Postconditions: 
;Author: 
;Date:          
Next:
        dec     R10                      
        jnz     Next
        ret

;Objective: Return from interrupt
;Preconditions: 
;Postconditions: 
;Author: 
;Date:         
fin_noDelay:
        bic.b   #00000110b, &P1IFG
        reti                           

;Objective: Return from interrupt
;Preconditions: 
;Postconditions: 
;Author: 
;Date: 
fin:
        Call    #Delay
        bic.b   #00000110b, &P1IFG
        reti                            

;Objective: Display 'OPTION' at the beggining
;Preconditions: 
;Postconditions: 
;Author: 
;Date: 
Option:
        mov.b   #0,R5 
	Call    #DrawLetter1
        Call    #DrawLetter5
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
        inc     R5
        Call    #DrawLetter6
        ret

;Objective: Interrupt Service Routine (ISR) that will be executed when the push button S1 is pressed.
;Preconditions: 
;Postconditions: 
;Author: 
;Date: 
PORT1_ISR:
        cmp     #0,R13
        jeq     state0
        cmp     #1,R13
        jeq     state1                  ;read option, either press S1 or S2
        cmp     #2,R13
        jeq     state2                  ;log option, either press S1 or S2
        cmp     #3,R13
        jeq     state3                  ;Waiting to start reading BPMs
        cmp     #4,R13
        jeq     state4                  ;beat and turns heart on for 0.2 seconds
        cmp     #5,R13
        jeq     state5                  ;Press S2 for transition to display SAVE
        cmp     #6,R13
        jeq     state6                  ;When displaying SAVE on LCD if S1 pressed it saves if S2 pressed it doesn't save
        cmp     #7,R13
        jeq     state7
        jmp     fin                     ; go to end of ISR

state0:
        bit.b   #00000010b, &P1IFG
        jnz     fin
        inc     R13

Reads:
        Call    #ClearLCD
        Mov     #5,R5
        Call    #DrawLetter1
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
 ;       Call    #Delay
        jmp     fin


state1:
        bit.b   #00000010b, &P1IFG
        jnz     readBPM             
        inc     R13


;Objective: Display 'LOG' when the push button S2 is pressed.
;Preconditions: LCD is cleared.
;Postconditions: 'LOG' is displayed on the screen. 
;Author: Dianelys Saldana
;Date: April 20th, 2021
Log:
      call      #ClearLCD
      mov       #9, R5

      mov.b     #0x1C,&0xA29                    ;L
      inc       R5
      push      R5
      mov       #0, R5

      mov.b     #0xFC,&0xA25                    ;O
      pop       R5

      mov.b     #0xBD,&0xA23                    ;G

      jmp fin


readBPM:
        Call    #ClearLCD
        mov.b   #00010000B,&0x0A31      ;brackets
        Mov     #3,R13
        jmp     fin

state2:
        bit.b   #00000010b, &P1IFG
        jnz     seeLog             
        dec     R13
        jmp     Reads

seeLog:
        push    R11
        mov.w   #0,R11
        mov.w   0x1980(R11),R7
        pop     R11
        Call    #DrawBPM
        Mov     #7,R13
        Call    #DrawResult
        Mov     #0,R15
        jmp     fin

state7:
        bit.b   #00000100b, &P1IFG
        jnz     fin_noDelay         
        cmp     #0,R15
        jeq     log2
        cmp     #1,R15
        jeq     log3
        Call    #Option
        Mov     #0,R13
        jmp     fin

log2:
        push    R11
        mov.w   #0,R11
        mov.w   0x1982(R11),R7
        pop     R11
        Call    #DrawBPM
        Mov     #7,R13
        Call    #DrawResult
        Inc     R15
        jmp     fin

log3:
        push    R11
        mov.w   #0,R11
        mov.w   0x1984(R11),R7
        pop     R11
        Call    #DrawBPM
        Mov     #7,R13
        Call    #DrawResult
        Inc     R15
        jmp     fin

state3:
        bit.b   #00000100b, &P1IFG
        jnz     fin
        inc     R13     ;Holds 4.
        Call    #startRead
        jmp     Beat

Beat:
        bic.b   #00000010b, &P1IFG	;Reset interrupt flag
        nop
        mov     #25000, &TA1CCR0
	;xor 	#CCIE, &TA0CCTL0
	;nop
	Mov.b   #00000100B, &0x0A22
        Mov     #1,R14
        ;inc     R5                     Better to do out of this label cuz of 1st beat

	jmp     fin

startRead:
        mov     #CCIE, &TA0CCTL0       ; Enable TACCR0 interrupt
        mov     #CCIE, &TA1CCTL0       ; Enable TACCR0 interrupt

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
        mov     #TASSEL_2+MC_1+ID_3, &TA1CTL
        MOV     #0,R6
        MOV     #1,R5

	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        mov     #25000, &TA0CCR0        ; Set the timer capture compare register 0
        
        mov     #0, &TA1CCR0
        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

	;nop				; required befor enabling interrupts

        ;bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        ;nop                             ; Required after enabling interrupts
        jmp     normal_fin

state4:
        inc     R5
        jmp     Beat

TIMER_A0_ISR:
        inc     timerResets
        ;cmp     #1, R14
        ;jeq     offHeart

        xor.b   #BIT7, P9OUT              ; just to toggle green LED each time the
                                        ; ISR is executed
        ;cmp #9, intsCounter             ; To toggle red LED each time the 
                                        ; interrupt counter reaches 10
        ;jnz noToggle
        ;xor.b #BIT0, P1OUT              ; Toggle red LED
                                        ; CCIFG automatically reset when entering
              	                        ; the ISR so no need to clear the flag
        cmp     #5,timerResets
        jeq     time
        ;mov #0, intsCounter
        reti
        
TIMER_A1_ISR:
        cmp     #1, R14
        jeq     offHeart
        jmp     fin
        

offHeart:
        Bic.b   #00000100B, &0x0A22
        Mov     #0,R14
        mov     #0, &TA1CCR0
        ;BIS.W   #1,&LCDCCTL0
        ;cmp     #5,timerResets
        ;jeq     time
        jmp     fin

time:
        inc     seconds
        inc     R6
        MOV     #0,timerResets
        cmp     #6,seconds
        jge     secTo0

        ;cmp     #30,R6
        ;jeq

        jmp     Battery

secTo0:
        ;Mov     #1,seconds

        ;cmp     #30,R6
        ;jeq
        Call    #DisplayBPM

        jmp     Battery

DisplayBPM:
        cmp     #6,R6
        jeq     BPM6
        cmp     #12,R6
        jeq     BPM12
        cmp     #18,R6
        jeq     BPM18
        cmp     #24,R6
        jeq     BPM24
        cmp     #30,R6
        jeq     BPM30

BPM6:
        Mov     #10,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Call    #DrawBPM
        ret

BPM12:
        Mov     #5,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Call    #DrawBPM
        ret

BPM18:           ;TODO
        Mov     #3,R12
        Mov     #0,R7
        Call    #mult
        Mov     #3,R12
        Call    #divi
        Call    #DrawResult
        Call    #DrawBPM
        ret

BPM24:           ;TODO
        Mov     #2,R12
        Mov     #0,R7
        Call    #mult
        Mov     #2,R12
        Call    #divi
        Call    #DrawResult
        Call    #DrawBPM
        ret

BPM30:
        Mov     #2,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Mov.b   #00001000B, &0x0A22
        Call    #DrawBPM
        ;mov     #0, &TA0CCR0
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL
        inc     R13
        ret

Battery:
        cmp     #1,seconds
        jeq     firstBar
        cmp     #2,seconds      ;1
        jeq     secondBar
        cmp     #3,seconds      ;2
        jeq     thirdBar
        cmp     #4,seconds      ;3
        jeq     fouthBar
        cmp     #5,seconds      ;4
        jeq     fifthBar
        cmp     #6,seconds      ;5
        jeq     sixthBar

firstBar:
        mov.b   #00110000B,&0x0A31      ;1 0x20
        mov.b   #00000000B,&0x0A2D      ;resets even bars
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

secondBar:
        mov.b   #00100000B,&0x0A2D      ;2 0x20
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

thirdBar:
        mov.b   #01110000B,&0x0A31      ;3 0x40
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

fouthBar:
        mov.b   #01100000B,&0x0A2D      ;4 0x40
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

fifthBar:
        mov.b   #11110000B,&0x0A31      ;5 0x80
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

sixthBar:
        mov.b   #11100000B,&0x0A2D      ;6 0x80
        Mov     #0,seconds
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt

divi:     
        cmp   #0,R5
        jeq   normal_fin
        cmp   #0,R12
        jeq   normal_fin
        sub   R5,R12
        jn    normal_fin
        add   #1,R7
        jmp   divi

mult:
        cmp     #0,R12
        jeq     normal_fin
        cmp     #0,R5
        jeq     normal_fin
        dec     R12
        add     R5,R7
        jmp     mult

state5:
      bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                      ; an interrupt generated by P1.1
                                      ; that corresponds to push button S1

      jnz      fin_noDelay          ; if no interrupt from push button


;Objective: Display 'SAVE' when the push button S1 is pressed.
;Preconditions: LCD is cleared.
;Postconditions: 'SAVE' is displayed on the screen.
;Author: Dianelys Saldana
;Date: April 20th, 2021
Save:
        Call    #ClearLCD
        mov     #14, R5

        mov.b   #10110111B,&0x0A29             ;S
        mov     #7, R5

        mov.b   #0xEF,&0xA25                   ;A
        mov     #15, R5

        mov.b   #00001100B,&0x0A23
        mov.b   #00101000B,&0x0A24             ;V
        mov     #6, R5

        mov.b   #0x9F,&0x0A32                  ;E
        inc      R13
        jmp      fin

state6:
        bit.b   #00000010b, &P1IFG
        jnz     SaveBPM
        Call    #Option
        Mov     #0,R13
        jmp     fin


;Objective: Save the last BPM that was read
;Preconditions: R11 will be used as index
;Postconditions: The last BPM was saved
;Author: Ignacio Tampe
;Date:        
SaveBPM:
        push.w R11 

        mov.w   #0,R11
        mov.w   0x1982(R11),0x1984(R11) ;Move 0x001982 to 0x001984
        mov.w   0x1980(R11),0x1982(R11) ;Move 0x001980 to 0x001982
        mov.w   R7,0x1980(R11) ;Move R7 to 0x001980
        Mov     #0,R13
        Call    #Option
        pop.w   R11
        jmp     fin


;Objective: 
;Preconditions: 
;Postconditions: 
;Author: 
;Date:          
DrawResult:
      Push      R15
      Mov       R7,R15
      Mov       #0,R9 
      Call      #Drawing100                ;If previous condition is not met, we start breaking down the result in 100, 10 and 1, displaying first the half stored in R12.
      Mov       #0,R9 
      Call      #Drawing10
      Mov       #0,R9 
      Call      #Drawing1
      Mov       R15,R7
      Pop       R15
      jmp       normal_fin


;Objective: 
;Preconditions: 
;Postconditions: 
;Author: 
;Date:    
Drawing100:
      cmp       #100,R7                  ;Compare that R12 is greater than 100.
      jge       reduce100                ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

      jmp       DrawDigit1 


;Objective: 
;Preconditions: 
;Postconditions: 
;Author: Jomar Santos
;Date: 
reduce100:                               
      Inc       R9                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #100,R7                  ;Subtract 100 from the half of the result stored in R12.

      cmp       #100,R7               
      jlo       DrawDigit1              ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce100 

Drawing10:
      cmp       #10,R7                  ;Compare that R12 is greater than 100.
      jge       reduce10                ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

      jmp       DrawDigit2 


;Objective: 
;Preconditions: 
;Postconditions: 
;Author: Jomar Santos
;Date:          
reduce10:                               
      Inc       R9                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #10,R7                   ;Subtract 100 from the half of the result stored in R12.

      cmp       #10,R7               
      jlo       DrawDigit2               ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce10

Drawing1:
      cmp       #1,R7                   ;Compare that R12 is greater than 100.
      jge       reduce1                 ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

      jmp       DrawDigit3


;Objective: 
;Preconditions: 
;Postconditions: 
;Author: Jomar Santos
;Date:    
reduce1:                               
      Inc       R9                      ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #1,R7                   ;Subtract 100 from the half of the result stored in R12.

      cmp       #1,R7               
      jlo       DrawDigit3              ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce1   

DrawBPM:
      mov.w     #10,R9
      call      #DrawDigit4
      mov.w     #11,R9
      call      #DrawDigit5
      mov.w     #12,R9
      call      #DrawDigit6
      ret

DrawDigit1:
      MOV.B     #9,R11                  ;Reuse R11 because why not
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit2:
      MOV.B     #5,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit3:
      MOV.B     #3,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit4:
      MOV.B     #2,R11
      MOV.B     DigitH(R9),0xA30(R11)
      MOV.B     DigitL(R9),0xA30+1(R11)
      ret

DrawDigit5:
      MOV.B     #14,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit6:
      MOV.B     #7,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret


ClearLCD:
        MOV.W   #2,&LCDCMEMCTL
        ret

DrawLetter1:
        MOV.B     #9,R11                  ;Reuse R11 because why not
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter2:
        MOV.B     #5,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter3:
        MOV.B     #3,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter4:
        MOV.B     #2,R11
        MOV.B     letterH(R5),0xA30(R11)
        MOV.B     letterL(R5),0xA30+1(R11)
        ret

DrawLetter5:
        MOV.B     #14,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter6:
        MOV.B     #7,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret


        END
