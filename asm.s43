; Interrupt Management Demostration
; Uses Timer_A0 to generate an interrupt every 0.5 seconds.  With this 
; interrupt green LED status is toggle so that it will light on every 1 second.
; Button S1 generates an interrupt used to toggle CCIE in TA0CCTL0.  With this
; the interrupt generation from Timer_A0 can be enable and disable.
;
; Author: José Navarro
; March 20, 2020
#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    PORT1_ISR               ; set vector for 'PORT1_ISR' routine

        ;ORG     0FFD4h                  ; vector for PORT1
        ;DC16    PORT2_ISR               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     01C00h
intsCounter     DW 0                    ; TIMER_A0 interrupts counter
seconds         DW 0
timerResets     DW 0                    ;When this hits 5, a second has passed

;Digits      0     1     2     3     4     5     6     7     8     9      B     P     M   
DigitH   db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0xF1, 0xCF, 0x6C
DigitL   db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0xA0

;Letters    O      P     T     I     N     R    E      A     D     L    G     B       P       M
letterH db 0xFC, 0xCF, 0x80, 0x90, 0x6C, 0xCF, 0x9F, 0xEF, 0xF0, 0x1C, 0xBD, 0xF1,   0xCF,   0x6C
letterL db 0x00, 0x00, 0x50, 0x50, 0x82, 0x02, 0x00, 0x00, 0x50, 0x00, 0x00, 0x50,   0x00,   0xA0

;Bat Seg     0     1     2     3     4     5    6
BatH     db 0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0
BatL     db 0x00, 0x00, 0x20, 0x20, 0x60, 0x60, 0xE0


        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2

        mov     #0, intsCounter         ; Clear intsCounter
        bis.b   #0FDh, &P1DIR           ; Port 1.1 for button input, all other as output
        bis.b   #0FFh, &P2DIR           ; All Port 2 pins as output
	bis.b   #0FFh, &P9DIR           ; All Port 9 pins as output
        bis.b   #00000001b, &P1OUT      ; Turn on red LED
        bic.b 	#0x80, P9OUT		; Turn off green LED

	bis.b   #02h, &P1OUT		; P1.1 Resistor enabled as pullup
        bis.b   #02h, &P1REN            ; resistor. Push is read as 0 and else 1

        bis.b   #02h, &P1IES            ; Int generated on high to low transition
        bis.b   #02h, &P1IE             ; Enable interrupt at P1.1

UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        MOV.W   #0x041e,&LCDCCTL0

        MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL     ;Clock sync Enabled
        
        MOV.W   #2,&LCDCMEMCTL         ;Clear LCD
        BIS.W   #1,&LCDCCTL0

        mov     #CCIE, &TA0CCTL0       ; Enable TACCR0 interrupt

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table

        mov.b   #00010000B,&0x0A31      ;brackets
        MOV     #0,R6
        MOV     #0,R5

	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        mov     #25000, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

	nop				; required befor enabling interrupts

        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)

TIMER_A0_ISR:
        inc     timerResets
        cmp     #1, R14
        jeq     offHeart

        xor.b   #BIT7, P9OUT              ; just to toggle green LED each time the
                                        ; ISR is executed
        ;cmp #9, intsCounter             ; To toggle red LED each time the 
                                        ; interrupt counter reaches 10
        ;jnz noToggle
        ;xor.b #BIT0, P1OUT              ; Toggle red LED
                                        ; CCIFG automatically reset when entering
              	                        ; the ISR so no need to clear the flag
        cmp     #5,timerResets
        jeq     time
        ;mov #0, intsCounter
        jmp     fin
;noToggle:
        ;inc intsCounter
fin:
        ;Mov     intsCounter,R14
        Mov     timerResets,R13
        reti
        
 fi:
        ret
        
offHeart:
        Bic.b   #00000100B, &0x0A22
        Mov     #0,R14
        ;BIS.W   #1,&LCDCCTL0
        cmp     #5,timerResets
        jeq     time
        jmp     fin
        
time:
        inc     seconds
        inc     R6
        MOV     #0,timerResets
        cmp     #6,seconds
        jge     secTo0
        
        ;cmp     #30,R6
        ;jeq

        jmp     Battery
        
        
        
secTo0:
        ;Mov     #1,seconds
        
        ;cmp     #30,R6
        ;jeq
        Call    #DisplayBPM
        
        jmp     Battery
        
        
DisplayBPM:
        cmp     #6,R6
        jeq     BPM6
        cmp     #12,R6
        jeq     BPM12
        cmp     #18,R6
        jeq     BPM18
        cmp     #24,R6
        jeq     BPM24
        cmp     #30,R6
        jeq     BPM30
        
        
BPM6:
        Mov     #10,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Call    #DrawBPM
        ret

        
BPM12:
        Mov     #5,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Call    #DrawBPM
        ret
        
        
BPM18:                  ;TODO
        Mov     #3,R12
        Mov     #0,R7
        Call    #mult
        Mov     #3,R12
        Call    #divi
        Call    #DrawResult
        Call    #DrawBPM
        ret
        
        
BPM24:                  ;TODO
        Mov     #2,R12
        Mov     #0,R7
        Call    #mult
        Mov     #2,R12
        Call    #divi
        Call    #DrawResult
        Call    #DrawBPM
        ret
        
        
BPM30:
        Mov     #2,R12
        Mov     #0,R7
        Call    #mult
        Call    #DrawResult
        Mov.b   #00001000B, &0x0A22
        Call    #DrawBPM
        ;mov     #0, &TA0CCR0
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL
        ret
        
Battery:
        cmp     #1,seconds
        jeq     firstBar
        cmp     #2,seconds     ;1
        jeq     secondBar
        cmp     #3,seconds      ;2
        jeq     thirdBar
        cmp     #4,seconds      ;3
        jeq     fouthBar
        cmp     #5,seconds      ;4
        jeq     fifthBar
        cmp     #6,seconds      ;5
        jeq     sixthBar
        
firstBar:
        mov.b   #00110000B,&0x0A31      ;1 0x20
        mov.b   #00000000B,&0x0A2D      ;resets even bars
        jmp     fin
        
        
secondBar:
        mov.b   #00100000B,&0x0A2D      ;2 0x20
        jmp     fin

thirdBar:
        mov.b   #01110000B,&0x0A31      ;3 0x40
        jmp     fin

fouthBar:
        mov.b   #01100000B,&0x0A2D      ;4 0x40
        jmp     fin

fifthBar:
        mov.b   #11110000B,&0x0A31      ;5 0x80
        jmp     fin

sixthBar:
        mov.b   #11100000B,&0x0A2D      ;6 0x80
        Mov     #0,seconds
        jmp     fin

PORT1_ISR:
	bic.b   #00000010b, &P1IFG	;Reset interrupt flag
        nop
	;xor 	#CCIE, &TA0CCTL0
	;nop
	Mov.b   #00000100B, &0x0A22
        Mov     #1,R14
        inc     R5

	jmp     fin
        
        
divi:     
        cmp   #0,R12
        jeq   fi
        cmp   #0,R5
        jeq   fi
        sub   R12,R5
        jn    fi
        add   #1,R7
        jmp   divi
        
mult:
        cmp     #0,R12
        jeq     fi
        cmp     #0,R5
        jeq     fi
        dec     R12
        add     R5,R7
        jmp     mult
      
      
DrawResult:
      Mov       #0,R9 
      Call      #Drawing100                ;If previous condition is not met, we start breaking down the result in 100, 10 and 1, displaying first the half stored in R12.
      Mov       #0,R9 
      Call      #Drawing10
      Mov       #0,R9 
      Call      #Drawing1
      jmp       fi
      
      
Drawing100:
      cmp       #100,R7                  ;Compare that R12 is greater than 100.
      jge       reduce100                 ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

      jmp       DrawDigit1 
      
      
reduce100:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
      Inc       R9                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #100,R7                 ;Subtract 100 from the half of the result stored in R12.

      cmp       #100,R7               
      jlo       DrawDigit1                  ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce100 
      
      
Drawing10:
      cmp       #10,R7                  ;Compare that R12 is greater than 100.
      jge       reduce10                 ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

      jmp       DrawDigit2 
      
      
reduce10:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
      Inc       R9                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #10,R7                 ;Subtract 100 from the half of the result stored in R12.

      cmp       #10,R7               
      jlo       DrawDigit2                  ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce10
      
      
Drawing1:
      cmp       #1,R7                  ;Compare that R12 is greater than 100.
      jge       reduce1                 ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.
      
      jmp       DrawDigit3
      
      
reduce1:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
      Inc       R9                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
      sub       #1,R7                 ;Subtract 100 from the half of the result stored in R12.

      cmp       #1,R7               
      jlo       DrawDigit3                  ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
      jmp       reduce1 
      
      
DrawBPM:
      mov.w     #10,R9
      call      #DrawDigit4
      mov.w     #11,R9
      call      #DrawDigit5
      mov.w     #12,R9
      call      #DrawDigit6
      ret
        
DrawDigit1:
      MOV.B     #9,R11 ;Reuse R11 because why not
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit2:
      MOV.B     #5,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit3:
      MOV.B     #3,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit4:
      MOV.B     #2,R11
      MOV.B     DigitH(R9),0xA30(R11)
      MOV.B     DigitL(R9),0xA30+1(R11)
      ret

DrawDigit5:
      MOV.B     #14,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret

DrawDigit6:
      MOV.B     #7,R11
      MOV.B     DigitH(R9),0xA20(R11)
      MOV.B     DigitL(R9),0xA20+1(R11)
      ret
        
PORT2_ISR: 
        jmp     fin

        END