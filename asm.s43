

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     01C00h                  ; To count how many times button S1 

;pushCount dw    0                       ; is pressed

;Digits      0     1     2     3     4     5    6    7      8     9
DigitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
DigitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

;Letters    O      P     T     I     N     R    E      A     D     L    G     B       P       M
letterH db 0xFC, 0xCF, 0x80, 0x90, 0x6C, 0xCF, 0x9F, 0xEF, 0xF0, 0x1C, 0xBD, 0xF1,   0xCF,   0x6C
letterL db 0x00, 0x00, 0x50, 0x50, 0x82, 0x02, 0x00, 0x00, 0x50, 0x00, 0x00, 0x50,   0x00,   0xA0


        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        ;DC16    PORT1_ISR              ; Interupt label
        
        
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     01C00h                  ; start of RAM



        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment


init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2
        
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

SetupP1:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for outpuu
        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        bic.b   #0x01,&P1OUT            ; Clear P1.0 and P9.7 output latch to
        bic.b   #0x80,&P9OUT            ; start with both off

        bis.b   #06h, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1
        bis.b   #06h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

        MOV.W   #0x041e,&LCDCCTL0
        
        MOV.W   #0x0208,&LCDCVCTL
        
        MOV.W   #0x8000,&LCDCCPCTL
        
        MOV.W   #2,&LCDCMEMCTL          ;Clears LCD memory
        
        ;Turn LCD on
        BIS.W   #1,&LCDCCTL0
        
nextDigitSetup:
        mov.b   #13,R14
        mov.b   #1,R9
        
        
Mainloop:

        CALL    #Start
        JMP $

        ;NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        ;bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        ;nop                             ; Wait after setting interrupt bit

;        bis     #LPM0,SR                ; Enter Low Power Mode 0
        ;NOP

        ;JMP $                           ; jump to current location '$'
        ;NOP 

        

Start:
        mov.b   #0,R5 
	Call    #DrawLetter1
        Call    #DrawLetter5
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
        inc     R5
        Call    #DrawLetter6
	jmp     Sequence
        
        
Sequence:
        mov.b   &P1IN,R5 
	and.b   #00000110B,R5
        ;cmp.b   #00000100B,R5
        ;jeq     NextDigit
        cmp.b   #00000010B,R5
        jeq     Reads
	jmp     Sequence
        
        
Reads:
        Call    #ClearLCD
        Mov     #5,R5
        Call    #DrawLetter1
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
        Call    #Delay
        jmp     Sequence2
        

Sequence2:
        mov.b   &P1IN,R5 
	and.b   #00000110B,R5
        ;cmp.b   #00000100B,R5
        ;jeq     NextDigit
        cmp.b   #00000010B,R5
        jeq     Log
	jmp     Sequence2
        
        
Log:
        Call    #ClearLCD
        Mov     #9,R5
        Call    #DrawLetter1
        inc     R5
        push    R5
        Mov     #0,R5
        Call    #DrawLetter2
        pop     R5
        Call    #DrawLetter3
        Call    #Delay
        jmp     Sequence2

NextDigit:
        MOV.B   #00010000B,0x0a30(R9)
        Call    #Delay
        MOV.B   #00110000B,0x0a30(R9)
        Call    #Delay
        MOV.B   #00100000B,0x0a20(R14)
        Call    #Delay
        MOV.B   #01110000B,0x0a30(R9)
        Call    #Delay
        MOV.B   #01100000B,0x0a20(R14)
        Call    #Delay
        MOV.B   #11110000B,0x0a30(R9)
        Call    #Delay
        MOV.B   #11100000B,0x0a20(R14)
        Call    #Delay
        MOV.B   #11110000B,0x0a20(R14)
        jmp     Start
        
Delay:
        Mov     #50000,R8
        Call    #Next
        Mov     #50000,R8
        Call    #Next
        jmp     fin
        
Next
        cmp     #0,R8
        jeq     fin
        dec     R8
        jmp     Next
        
        
DrawLetter1:
        MOV.B     #9,R11 ;Reuse R11 because why not
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter2:
        MOV.B     #5,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter3:
        MOV.B     #3,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter4:
        MOV.B     #2,R11
        MOV.B     letterH(R5),0xA30(R11)
        MOV.B     letterL(R5),0xA30+1(R11)
        ret

DrawLetter5:
        MOV.B     #14,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter6:
        MOV.B     #7,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret
        
        
ClearLCD:
        MOV.W   #2,&LCDCMEMCTL
        jmp     fin
        
        
intReturn:

        reti                            ; Return from interrupt
    
fin:    RET

        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        NOP
        END
