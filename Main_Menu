; Interrupt Management Demostration
; Program Port 1 to generate an interrupt everytime the push button
; S1 on the launchpad is pressed. The first time the red LED will 
; be light on. The second time the green LED will be light on. Next
; times will cause no changes.
;

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        
        ORG     01C00h                  ; To count how many times button S1 
pushCount dw    0                       ; is pressed
seconds         DW 0
timerResets     DW 0                    ;When this hits 5, a second has passed

;Digits      0     1     2     3     4     5     6     7     8     9      B     P     M   
DigitH   db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0xF1, 0xCF, 0x6C
DigitL   db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0xA0

;Letters    O      P     T     I     N     R    E      A     D     L    G     B       P       M
letterH db 0xFC, 0xCF, 0x80, 0x90, 0x6C, 0xCF, 0x9F, 0xEF, 0xF0, 0x1C, 0xBD, 0xF1,   0xCF,   0x6C
letterL db 0x00, 0x00, 0x50, 0x50, 0x82, 0x02, 0x00, 0x00, 0x50, 0x00, 0x00, 0x50,   0x00,   0xA0

;Bat Seg     0     1     2     3     4     5    6
BatH     db 0x10, 0x30, 0x30, 0x70, 0x70, 0xF0, 0xF0
BatL     db 0x00, 0x00, 0x20, 0x20, 0x60, 0x60, 0xE0

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
                                                       
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

;Has some design errors like not initializing pushCount to 0 in the code.
;The program don't clear the push button interrupt flag at the beginning
;leaving the possibility of a false interrupt due to a previous push
;(this is solved uncommenting the two lines of codes)

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT

        bis.b   #06h, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1
        bis.b   #06h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

//        mov     #0, pushCount         ; When using reset with the debugger
                                        ; the memory content is not reset to
                                        ; original values. To take care of
                                        ; that situation pushCount is reset
                                        ; to 0
  
        bic.b   #00000110b, &P1IFG    ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        MOV.W   #0x041e,&LCDCCTL0

        MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL     ;Clock sync Enabled


        MOV.W   #2,&LCDCMEMCTL         ;Clear LCD
        BIS.W   #1,&LCDCCTL0
        

        Mov     #0,R13
        
        
Start:
        mov.b   #0,R5 
	Call    #DrawLetter1
        Call    #DrawLetter5
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
        inc     R5
        Call    #DrawLetter6


        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

;        bis     #LPM0,SR                ; Enter Low Power Mode 0
        NOP

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)

;Interrupt Service Routine (ISR) that will be executed when the push button S1
;is pressed.

PORT1_ISR:
        cmp     #0,R13
        jeq     state1
        cmp     #1,R13
        jeq     state2                  ;read option, either press S1 or S2
        cmp     #2,R13
        jeq     state3                  ;log option, either press S1 or S2
    ;    cmp     #3,R113
     ;   jeq
        jmp     fin                     ; go to end of ISR

state1:
        bit.b   #00000010b, &P1IFG
        jnz     fin
        inc     R13
        

Reads:
        Call    #ClearLCD
        Mov     #5,R5
        Call    #DrawLetter1
        inc     R5
        Call    #DrawLetter2
        inc     R5
        Call    #DrawLetter3
        inc     R5
        Call    #DrawLetter4
 ;       Call    #Delay
        jmp     fin
        
        
state2:
        bit.b   #00000010b, &P1IFG
        jnz     fin             ;va readBPM
        inc     R13
        
Log:
        Call    #ClearLCD
        Mov     #9,R5
        Call    #DrawLetter1
        inc     R5
        push    R5
        Mov     #0,R5
        Call    #DrawLetter2
        pop     R5
        Call    #DrawLetter3
        ;Call    #Delay
        jmp     fin
        
state3:
        bit.b   #00000010b, &P1IFG
        jnz     fin             ;va log option of watching previous BPMs
        dec     R13
        jmp     Reads
        
ClearLCD:
        MOV.W   #2,&LCDCMEMCTL
        ret

DrawLetter1:
        MOV.B     #9,R11 ;Reuse R11 because why not
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter2:
        MOV.B     #5,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter3:
        MOV.B     #3,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter4:
        MOV.B     #2,R11
        MOV.B     letterH(R5),0xA30(R11)
        MOV.B     letterL(R5),0xA30+1(R11)
        ret

DrawLetter5:
        MOV.B     #14,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret

DrawLetter6:
        MOV.B     #7,R11
        MOV.B     letterH(R5),0xA20(R11)
        MOV.B     letterL(R5),0xA20+1(R11)
        ret
        
        
notFirst:
        bis.b   #10000000b,&P9OUT       ; light on the green LED
        
fin:
        bic.b   #00000110b, &P1IFG
        reti                            ; Return from interrupt


        END
